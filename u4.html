<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>SimplicialSurface</title>
		<style>
			body { margin: 0; }
		</style>


	</head>
	<body>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>


<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/",
			"gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
		}
	}
</script>


<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GUI } from 'gui';
	import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';

	//start scene and camera
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );

	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	//Lights
	const skyColor = 0xFFFFFF;
	const skyIntensity = 0.3;
	const skyLight = new THREE.AmbientLight(skyColor, skyIntensity);
	scene.add(skyLight);

	const color = 0xFFFFFF;
	const intensity = 1;
	const light = new THREE.PointLight(color, intensity);
	light.position.set(0, 3, -5);
	scene.add(light);

	//create groups to add everything to
	const meshRoot = new THREE.Group();
	const wireRoot = new THREE.Group();
	const vertexRoot = new THREE.Group();
	const vertexlabelRoot = new THREE.Group();
	const edgeRoot = new THREE.Group();
	const ringRoot = new THREE.Group();
	const normalsRoot = new THREE.Group();
	const normalMeshRoot = new THREE.Group();

	//parameters for the controls on the top right
	var guiParameters = new function() { 
		this.speedX = 0.0; 
		this.speedY = 0.0; 
		this.speedZ = 0.0;
		this.transparency = 1;
		this.edgeVisibility = false;
		this.edgeWidth = 0.2;

		this.vertexVisibility = true;
		this.vertexlabelVisibility = false;
		this.vertexSize = 1;
		this.planeX = 0.0;
		this.minX = -1.5;
		this.maxX = 1.5;
		this.planeXactive = false;
		this.planeY = 0.0;
		this.minY = -1.5;

		this.maxY = 1.5;
		this.planeYactive = false;
		this.planeZ = 0.0;
		this.minZ = -1.5;
		this.maxZ = 1.5;
		this.planeZactive = false;
		this.normalsMaterial = false;
		this.circleVisibility = false;
		this.circleWidth = 0.005;
		this.normalsVisibility = false;
		this.normalsLength = 1;
	} ;

	//generate the plane for intersections
	const planeX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), guiParameters.planeX );
	const planeY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), guiParameters.planeY );
	const planeZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), guiParameters.planeZ );

	// the array which ones are currently active
	var activePlanes = [];

	//rederer for lables
	const labelRenderer = new CSS2DRenderer();
	labelRenderer.setSize( window.innerWidth, window.innerHeight );
	labelRenderer.domElement.style.position = 'absolute';
	labelRenderer.domElement.style.top = '0px';
	document.body.appendChild( labelRenderer.domElement );
	
	//controls for mouse 
	const controls = new OrbitControls( camera, labelRenderer.domElement );

	//controls in the top right corner
	var gui = new GUI();

	const animationFolder = gui.addFolder("Animations");
	animationFolder.add(guiParameters, 'speedX', 0, 5);
	animationFolder.add(guiParameters, 'speedY', 0, 5);
	animationFolder.add(guiParameters, 'speedZ', 0, 5);
	animationFolder.open();

	const controlFolder = gui.addFolder("Controls");
	controlFolder.add(guiParameters, "transparency", 0, 1);
	controlFolder.add(guiParameters, "edgeVisibility");
	var edgeWidthGUI = controlFolder.add(guiParameters, "edgeWidth", 0.01, 2);
	controlFolder.add(guiParameters, "vertexVisibility");
	controlFolder.add(guiParameters, "vertexlabelVisibility");
	controlFolder.add(guiParameters, "vertexSize", 0.1, 3);
	controlFolder.add(guiParameters, "normalsMaterial");
	controlFolder.add(guiParameters, "circleVisibility");
	controlFolder.add(guiParameters, "circleWidth", 0.0001, 0.1);
	controlFolder.add(guiParameters, "normalsVisibility");
	controlFolder.add(guiParameters, "normalsLength", 0, 2);
	controlFolder.open();

	//generate a sphere geometry for the vertices
	const sphereGeometry = new THREE.SphereGeometry( 0.02, 32, 16 );
	sphereGeometry.transparent = guiParameters.vertexVisibility;
	
	//functions for later calculations

	function calulateIncenter(A, B, C){
		//we follow the math and variable names from here: https://math.stackexchange.com/questions/740111/incenter-of-triangle-in-3d
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var res = [];
		res[0] = a/(a+b+c)*A[0] + b/(a+b+c)*B[0] + c/(a+b+c)*C[0];
		res[1] = a/(a+b+c)*A[1] + b/(a+b+c)*B[1] + c/(a+b+c)*C[1];
		res[2] = a/(a+b+c)*A[2] + b/(a+b+c)*B[2] + c/(a+b+c)*C[2];

		return res;
	}

	function calulateInradius(A, B, C){
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var s = (a+b+c)/2;
		var inradius = Math.sqrt(((s-a)*(s-b)*(s-c)) / s );

		return inradius;
	}

	// --- start of generated output --- //

	// preperations for parameterized vertex coordinates 
	const vertexParametriziation = false;
	// generate the faces color by color 
	const geometry1 = new THREE.BufferGeometry();
	function setVertices1(){
		var vertices1 = new Float32Array( [
				1.5,0.8660254040000001,0.,
			2.5,0.8660254040000001,0.,
			2.,1.154700539,0.8164965809,

			1.5,0.8660254040000001,0.,
			1.,1.154700539,0.8164965809,
			2.,1.154700539,0.8164965809,

			1.5,0.8660254040000001,0.,
			0.5,0.8660254040000001,0.,
			1.,1.154700539,0.8164965809,

			1.5,0.8660254040000001,0.,
			0.5,0.8660254040000001,0.,
			1.,0.,0.,

			1.5,0.8660254040000001,0.,
			1.,0.,0.,
			2.,0.,0.,

			1.5,0.8660254040000001,0.,
			2.,0.,0.,
			2.5,0.8660254040000001,0.,

			0.5,0.8660254040000001,0.,
			1.,1.154700539,0.8164965809,
			0.5,0.2886751347,0.8164965809,

			0.5,0.8660254040000001,0.,
			0.5,0.2886751347,0.8164965809,
			1.,0.,0.,

					] ); 

		return vertices1; 
	}

	geometry1.setAttribute( 'position', new THREE.BufferAttribute( setVertices1(), 3 ) );

	// generate materials in the given color and normals material for the faces 

    const materialNormal1 = new THREE.MeshNormalMaterial({
        flatShading: true,
    });
    materialNormal1.transparent = true;
    materialNormal1.side = THREE.DoubleSide;
        
    const material1 = new THREE.MeshPhongMaterial({
        color: 0x32cd32,
        flatShading: true,
    });
    material1.transparent = true;
    material1.side = THREE.DoubleSide;
        
	// generate meshes for the faces from the materials with the vertex coordinates from before 

    const mesh1 = new THREE.Mesh( geometry1, material1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    meshRoot.add(mesh1);
        
    const meshNormal1 = new THREE.Mesh( geometry1, materialNormal1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    normalMeshRoot.add(meshNormal1);
        	const geometry2 = new THREE.BufferGeometry();
	function setVertices2(){
		var vertices2 = new Float32Array( [
				1.5,0.2886751347,0.8164965809,
			1.,1.154700539,0.8164965809,
			0.5,0.2886751347,0.8164965809,

			1.5,0.2886751347,0.8164965809,
			1.,1.154700539,0.8164965809,
			2.,1.154700539,0.8164965809,

			1.5,0.2886751347,0.8164965809,
			2.5,0.2886751347,0.8164965809,
			2.,1.154700539,0.8164965809,

			1.5,0.2886751347,0.8164965809,
			2.5,0.2886751347,0.8164965809,
			2.,0.,0.,

			1.5,0.2886751347,0.8164965809,
			1.,0.,0.,
			2.,0.,0.,

			1.5,0.2886751347,0.8164965809,
			0.5,0.2886751347,0.8164965809,
			1.,0.,0.,

			2.5,0.2886751347,0.8164965809,
			2.5,0.8660254040000001,0.,
			2.,1.154700539,0.8164965809,

			2.5,0.2886751347,0.8164965809,
			2.,0.,0.,
			2.5,0.8660254040000001,0.,

					] ); 

		return vertices2; 
	}

	geometry2.setAttribute( 'position', new THREE.BufferAttribute( setVertices2(), 3 ) );

	// generate materials in the given color and normals material for the faces 

    const materialNormal2 = new THREE.MeshNormalMaterial({
        flatShading: true,
    });
    materialNormal2.transparent = true;
    materialNormal2.side = THREE.DoubleSide;
        
    const material2 = new THREE.MeshPhongMaterial({
        color: 0x049EF4,
        flatShading: true,
    });
    material2.transparent = true;
    material2.side = THREE.DoubleSide;
        
	// generate meshes for the faces from the materials with the vertex coordinates from before 

    const mesh2 = new THREE.Mesh( geometry2, material2 );
    mesh2.castShadow = true;                         
    mesh2.receiveShadow = true;                      
                                
    meshRoot.add(mesh2);
        
    const meshNormal2 = new THREE.Mesh( geometry2, materialNormal2 );
    mesh2.castShadow = true;                         
    mesh2.receiveShadow = true;                      
                                
    normalMeshRoot.add(meshNormal2);
        
	// generate the edges grouped by color
		controlFolder.remove(edgeWidthGUI);

    const edgeMaterial1 = new THREE.LineBasicMaterial( {
        color: 0x000000,
        linewidth: 3.,
    } );
        
	function getEdges1(){
		const edges1 = new Float32Array( [
			1.5,0.86602540400000005,0.,
			2.,1.154700539,0.81649658089999999,

			1.5,0.86602540400000005,0.,
			2.5,0.86602540400000005,0.,

			1.5,0.86602540400000005,0.,
			1.,1.154700539,0.81649658089999999,

			1.5,0.86602540400000005,0.,
			0.5,0.86602540400000005,0.,

			0.5,0.86602540400000005,0.,
			1.,1.154700539,0.81649658089999999,

			1.5,0.86602540400000005,0.,
			1.,0.,0.,

			0.5,0.86602540400000005,0.,
			1.,0.,0.,

			1.5,0.86602540400000005,0.,
			2.,0.,0.,

			0.5,0.86602540400000005,0.,
			0.5,0.2886751347,0.81649658089999999,

			1.5,0.2886751347,0.81649658089999999,
			1.,1.154700539,0.81649658089999999,

			1.5,0.2886751347,0.81649658089999999,
			0.5,0.2886751347,0.81649658089999999,

			1.5,0.2886751347,0.81649658089999999,
			2.,1.154700539,0.81649658089999999,

			1.5,0.2886751347,0.81649658089999999,
			2.5,0.2886751347,0.81649658089999999,

			2.5,0.2886751347,0.81649658089999999,
			2.,1.154700539,0.81649658089999999,

			1.5,0.2886751347,0.81649658089999999,
			2.,0.,0.,

			2.5,0.2886751347,0.81649658089999999,
			2.,0.,0.,

			1.5,0.2886751347,0.81649658089999999,
			1.,0.,0.,

			2.5,0.2886751347,0.81649658089999999,
			2.5,0.86602540400000005,0.,

		]);
		return edges1;
	}


	// generate geometries and lines for the edges 

    const edgeGeometry1 = new THREE.BufferGeometry();
    edgeGeometry1.setAttribute( 'position', new THREE.BufferAttribute( getEdges1(), 3 ) );

    const edgeLine1 = new THREE.LineSegments( edgeGeometry1, edgeMaterial1 );
    edgeRoot.add(edgeLine1);
        
	// update function to be called every frame 

    const edgeMaterial2 = new THREE.LineBasicMaterial( {
        color: 0xFF0000,
        linewidth: 3.,
    } );
        
	function getEdges2(){
		const edges2 = new Float32Array( [
			1.,1.154700539,0.81649658089999999,
			0.5,0.2886751347,0.81649658089999999,

			0.5,0.2886751347,0.81649658089999999,
			1.,0.,0.,

			1.,0.,0.,
			2.,0.,0.,

			2.,0.,0.,
			2.5,0.86602540400000005,0.,

			2.5,0.86602540400000005,0.,
			2.,1.154700539,0.81649658089999999,

			1.,1.154700539,0.81649658089999999,
			2.,1.154700539,0.81649658089999999,

		]);
		return edges2;
	}


	// generate geometries and lines for the edges 

    const edgeGeometry2 = new THREE.BufferGeometry();
    edgeGeometry2.setAttribute( 'position', new THREE.BufferAttribute( getEdges2(), 3 ) );

    const edgeLine2 = new THREE.LineSegments( edgeGeometry2, edgeMaterial2 );
    edgeRoot.add(edgeLine2);
        
	// update function to be called every frame 
	// generate labels and spheres for the vertices


	function getVertex1(){
		return [1.5,0.86602540400000005,0.,];
	}
	const sphereMaterial1 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere1 = new THREE.Mesh( sphereGeometry, sphereMaterial1 );
	vertexRoot.add(sphere1);
	sphere1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);

    const lableDiv1 = document.createElement( 'div' );
    lableDiv1.className = 'label';
    lableDiv1.textContent = '1';
    lableDiv1.style.marginTop = '-1em';

    const vertexLabel1 = new CSS2DObject( lableDiv1 );
    vertexLabel1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);
    vertexlabelRoot.add( vertexLabel1 );
            
            

	function getVertex4(){
		return [0.5,0.86602540400000005,0.,];
	}
	const sphereMaterial4 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere4 = new THREE.Mesh( sphereGeometry, sphereMaterial4 );
	vertexRoot.add(sphere4);
	sphere4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);

    const lableDiv4 = document.createElement( 'div' );
    lableDiv4.className = 'label';
    lableDiv4.textContent = '4';
    lableDiv4.style.marginTop = '-1em';

    const vertexLabel4 = new CSS2DObject( lableDiv4 );
    vertexLabel4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);
    vertexlabelRoot.add( vertexLabel4 );
            
            

	function getVertex24(){
		return [1.5,0.2886751347,0.81649658089999999,];
	}
	const sphereMaterial24 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere24 = new THREE.Mesh( sphereGeometry, sphereMaterial24 );
	vertexRoot.add(sphere24);
	sphere24.position.set(getVertex24()[0],getVertex24()[1],getVertex24()[2]);

    const lableDiv24 = document.createElement( 'div' );
    lableDiv24.className = 'label';
    lableDiv24.textContent = '24';
    lableDiv24.style.marginTop = '-1em';

    const vertexLabel24 = new CSS2DObject( lableDiv24 );
    vertexLabel24.position.set(getVertex24()[0],getVertex24()[1],getVertex24()[2]);
    vertexlabelRoot.add( vertexLabel24 );
            
            

	function getVertex27(){
		return [2.5,0.2886751347,0.81649658089999999,];
	}
	const sphereMaterial27 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere27 = new THREE.Mesh( sphereGeometry, sphereMaterial27 );
	vertexRoot.add(sphere27);
	sphere27.position.set(getVertex27()[0],getVertex27()[1],getVertex27()[2]);

    const lableDiv27 = document.createElement( 'div' );
    lableDiv27.className = 'label';
    lableDiv27.textContent = '27';
    lableDiv27.style.marginTop = '-1em';

    const vertexLabel27 = new CSS2DObject( lableDiv27 );
    vertexLabel27.position.set(getVertex27()[0],getVertex27()[1],getVertex27()[2]);
    vertexlabelRoot.add( vertexLabel27 );
            
            

	function getVertex32(){
		return [1.,1.154700539,0.81649658089999999,];
	}
	const sphereMaterial32 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere32 = new THREE.Mesh( sphereGeometry, sphereMaterial32 );
	vertexRoot.add(sphere32);
	sphere32.position.set(getVertex32()[0],getVertex32()[1],getVertex32()[2]);

    const lableDiv32 = document.createElement( 'div' );
    lableDiv32.className = 'label';
    lableDiv32.textContent = '32';
    lableDiv32.style.marginTop = '-1em';

    const vertexLabel32 = new CSS2DObject( lableDiv32 );
    vertexLabel32.position.set(getVertex32()[0],getVertex32()[1],getVertex32()[2]);
    vertexlabelRoot.add( vertexLabel32 );
            
            

	function getVertex33(){
		return [0.5,0.2886751347,0.81649658089999999,];
	}
	const sphereMaterial33 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere33 = new THREE.Mesh( sphereGeometry, sphereMaterial33 );
	vertexRoot.add(sphere33);
	sphere33.position.set(getVertex33()[0],getVertex33()[1],getVertex33()[2]);

    const lableDiv33 = document.createElement( 'div' );
    lableDiv33.className = 'label';
    lableDiv33.textContent = '33';
    lableDiv33.style.marginTop = '-1em';

    const vertexLabel33 = new CSS2DObject( lableDiv33 );
    vertexLabel33.position.set(getVertex33()[0],getVertex33()[1],getVertex33()[2]);
    vertexlabelRoot.add( vertexLabel33 );
            
            

	function getVertex34(){
		return [1.,0.,0.,];
	}
	const sphereMaterial34 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere34 = new THREE.Mesh( sphereGeometry, sphereMaterial34 );
	vertexRoot.add(sphere34);
	sphere34.position.set(getVertex34()[0],getVertex34()[1],getVertex34()[2]);

    const lableDiv34 = document.createElement( 'div' );
    lableDiv34.className = 'label';
    lableDiv34.textContent = '34';
    lableDiv34.style.marginTop = '-1em';

    const vertexLabel34 = new CSS2DObject( lableDiv34 );
    vertexLabel34.position.set(getVertex34()[0],getVertex34()[1],getVertex34()[2]);
    vertexlabelRoot.add( vertexLabel34 );
            
            

	function getVertex35(){
		return [2.,0.,0.,];
	}
	const sphereMaterial35 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere35 = new THREE.Mesh( sphereGeometry, sphereMaterial35 );
	vertexRoot.add(sphere35);
	sphere35.position.set(getVertex35()[0],getVertex35()[1],getVertex35()[2]);

    const lableDiv35 = document.createElement( 'div' );
    lableDiv35.className = 'label';
    lableDiv35.textContent = '35';
    lableDiv35.style.marginTop = '-1em';

    const vertexLabel35 = new CSS2DObject( lableDiv35 );
    vertexLabel35.position.set(getVertex35()[0],getVertex35()[1],getVertex35()[2]);
    vertexlabelRoot.add( vertexLabel35 );
            
            

	function getVertex36(){
		return [2.5,0.86602540400000005,0.,];
	}
	const sphereMaterial36 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere36 = new THREE.Mesh( sphereGeometry, sphereMaterial36 );
	vertexRoot.add(sphere36);
	sphere36.position.set(getVertex36()[0],getVertex36()[1],getVertex36()[2]);

    const lableDiv36 = document.createElement( 'div' );
    lableDiv36.className = 'label';
    lableDiv36.textContent = '36';
    lableDiv36.style.marginTop = '-1em';

    const vertexLabel36 = new CSS2DObject( lableDiv36 );
    vertexLabel36.position.set(getVertex36()[0],getVertex36()[1],getVertex36()[2]);
    vertexlabelRoot.add( vertexLabel36 );
            
            

	function getVertex37(){
		return [2.,1.154700539,0.81649658089999999,];
	}
	const sphereMaterial37 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere37 = new THREE.Mesh( sphereGeometry, sphereMaterial37 );
	vertexRoot.add(sphere37);
	sphere37.position.set(getVertex37()[0],getVertex37()[1],getVertex37()[2]);

    const lableDiv37 = document.createElement( 'div' );
    lableDiv37.className = 'label';
    lableDiv37.textContent = '37';
    lableDiv37.style.marginTop = '-1em';

    const vertexLabel37 = new CSS2DObject( lableDiv37 );
    vertexLabel37.position.set(getVertex37()[0],getVertex37()[1],getVertex37()[2]);
    vertexlabelRoot.add( vertexLabel37 );
            
            	// generate the rings for the incircles 

	var inradius1 = calulateInradius(getVertex1(), getVertex36(), getVertex37());
	var incenter1 = calulateIncenter(getVertex1(), getVertex36(), getVertex37());
	var ringGeometry1 = new THREE.RingGeometry((inradius1 - 0.005),inradius1, 32);
	const ringMaterial1 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh1 = new THREE.Mesh(ringGeometry1, ringMaterial1);

	function setCircleRotation1(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 2.5,0.86602540400000005,0.],[2.,1.154700539,0.81649658089999999]);

        ringMesh1.position.setX(incenter[0]);
        ringMesh1.position.setY(incenter[1]);
        ringMesh1.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex36(), getVertex37());
        var relRadius = inradius/inradius1;

        ringMesh1.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A1 = new THREE.Vector3(1.5,0.86602540400000005,0.);
        const B1 = new THREE.Vector3(2.5,0.86602540400000005,0.);
        const C1 = new THREE.Vector3(2.,1.154700539,0.81649658089999999);

        const normalVec1 = new THREE.Vector3();
        normalVec1.crossVectors(B1.sub(A1), C1.sub(A1));
        normalVec1.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal1 = new THREE.Vector3(0,0,1);

        const quaternionRotation1 = new THREE.Quaternion();
        quaternionRotation1.setFromUnitVectors(initialNormal1, normalVec1);

        ringMesh1.setRotationFromQuaternion(quaternionRotation1);

        return quaternionRotation1;
    }

    ringRoot.add(ringMesh1);
            
	var inradius2 = calulateInradius(getVertex1(), getVertex32(), getVertex37());
	var incenter2 = calulateIncenter(getVertex1(), getVertex32(), getVertex37());
	var ringGeometry2 = new THREE.RingGeometry((inradius2 - 0.005),inradius2, 32);
	const ringMaterial2 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh2 = new THREE.Mesh(ringGeometry2, ringMaterial2);

	function setCircleRotation2(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 1.,1.154700539,0.81649658089999999],[2.,1.154700539,0.81649658089999999]);

        ringMesh2.position.setX(incenter[0]);
        ringMesh2.position.setY(incenter[1]);
        ringMesh2.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex32(), getVertex37());
        var relRadius = inradius/inradius2;

        ringMesh2.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A2 = new THREE.Vector3(1.5,0.86602540400000005,0.);
        const B2 = new THREE.Vector3(1.,1.154700539,0.81649658089999999);
        const C2 = new THREE.Vector3(2.,1.154700539,0.81649658089999999);

        const normalVec2 = new THREE.Vector3();
        normalVec2.crossVectors(B2.sub(A2), C2.sub(A2));
        normalVec2.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal2 = new THREE.Vector3(0,0,1);

        const quaternionRotation2 = new THREE.Quaternion();
        quaternionRotation2.setFromUnitVectors(initialNormal2, normalVec2);

        ringMesh2.setRotationFromQuaternion(quaternionRotation2);

        return quaternionRotation2;
    }

    ringRoot.add(ringMesh2);
            
	var inradius3 = calulateInradius(getVertex1(), getVertex4(), getVertex32());
	var incenter3 = calulateIncenter(getVertex1(), getVertex4(), getVertex32());
	var ringGeometry3 = new THREE.RingGeometry((inradius3 - 0.005),inradius3, 32);
	const ringMaterial3 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh3 = new THREE.Mesh(ringGeometry3, ringMaterial3);

	function setCircleRotation3(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 0.5,0.86602540400000005,0.],[1.,1.154700539,0.81649658089999999]);

        ringMesh3.position.setX(incenter[0]);
        ringMesh3.position.setY(incenter[1]);
        ringMesh3.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex4(), getVertex32());
        var relRadius = inradius/inradius3;

        ringMesh3.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A3 = new THREE.Vector3(1.5,0.86602540400000005,0.);
        const B3 = new THREE.Vector3(0.5,0.86602540400000005,0.);
        const C3 = new THREE.Vector3(1.,1.154700539,0.81649658089999999);

        const normalVec3 = new THREE.Vector3();
        normalVec3.crossVectors(B3.sub(A3), C3.sub(A3));
        normalVec3.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal3 = new THREE.Vector3(0,0,1);

        const quaternionRotation3 = new THREE.Quaternion();
        quaternionRotation3.setFromUnitVectors(initialNormal3, normalVec3);

        ringMesh3.setRotationFromQuaternion(quaternionRotation3);

        return quaternionRotation3;
    }

    ringRoot.add(ringMesh3);
            
	var inradius4 = calulateInradius(getVertex1(), getVertex4(), getVertex34());
	var incenter4 = calulateIncenter(getVertex1(), getVertex4(), getVertex34());
	var ringGeometry4 = new THREE.RingGeometry((inradius4 - 0.005),inradius4, 32);
	const ringMaterial4 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh4 = new THREE.Mesh(ringGeometry4, ringMaterial4);

	function setCircleRotation4(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 0.5,0.86602540400000005,0.],[1.,0.,0.]);

        ringMesh4.position.setX(incenter[0]);
        ringMesh4.position.setY(incenter[1]);
        ringMesh4.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex4(), getVertex34());
        var relRadius = inradius/inradius4;

        ringMesh4.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A4 = new THREE.Vector3(1.5,0.86602540400000005,0.);
        const B4 = new THREE.Vector3(0.5,0.86602540400000005,0.);
        const C4 = new THREE.Vector3(1.,0.,0.);

        const normalVec4 = new THREE.Vector3();
        normalVec4.crossVectors(B4.sub(A4), C4.sub(A4));
        normalVec4.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal4 = new THREE.Vector3(0,0,1);

        const quaternionRotation4 = new THREE.Quaternion();
        quaternionRotation4.setFromUnitVectors(initialNormal4, normalVec4);

        ringMesh4.setRotationFromQuaternion(quaternionRotation4);

        return quaternionRotation4;
    }

    ringRoot.add(ringMesh4);
            
	var inradius5 = calulateInradius(getVertex1(), getVertex34(), getVertex35());
	var incenter5 = calulateIncenter(getVertex1(), getVertex34(), getVertex35());
	var ringGeometry5 = new THREE.RingGeometry((inradius5 - 0.005),inradius5, 32);
	const ringMaterial5 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh5 = new THREE.Mesh(ringGeometry5, ringMaterial5);

	function setCircleRotation5(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 1.,0.,0.],[2.,0.,0.]);

        ringMesh5.position.setX(incenter[0]);
        ringMesh5.position.setY(incenter[1]);
        ringMesh5.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex34(), getVertex35());
        var relRadius = inradius/inradius5;

        ringMesh5.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A5 = new THREE.Vector3(1.5,0.86602540400000005,0.);
        const B5 = new THREE.Vector3(1.,0.,0.);
        const C5 = new THREE.Vector3(2.,0.,0.);

        const normalVec5 = new THREE.Vector3();
        normalVec5.crossVectors(B5.sub(A5), C5.sub(A5));
        normalVec5.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal5 = new THREE.Vector3(0,0,1);

        const quaternionRotation5 = new THREE.Quaternion();
        quaternionRotation5.setFromUnitVectors(initialNormal5, normalVec5);

        ringMesh5.setRotationFromQuaternion(quaternionRotation5);

        return quaternionRotation5;
    }

    ringRoot.add(ringMesh5);
            
	var inradius6 = calulateInradius(getVertex1(), getVertex35(), getVertex36());
	var incenter6 = calulateIncenter(getVertex1(), getVertex35(), getVertex36());
	var ringGeometry6 = new THREE.RingGeometry((inradius6 - 0.005),inradius6, 32);
	const ringMaterial6 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh6 = new THREE.Mesh(ringGeometry6, ringMaterial6);

	function setCircleRotation6(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 2.,0.,0.],[2.5,0.86602540400000005,0.]);

        ringMesh6.position.setX(incenter[0]);
        ringMesh6.position.setY(incenter[1]);
        ringMesh6.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex35(), getVertex36());
        var relRadius = inradius/inradius6;

        ringMesh6.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A6 = new THREE.Vector3(1.5,0.86602540400000005,0.);
        const B6 = new THREE.Vector3(2.,0.,0.);
        const C6 = new THREE.Vector3(2.5,0.86602540400000005,0.);

        const normalVec6 = new THREE.Vector3();
        normalVec6.crossVectors(B6.sub(A6), C6.sub(A6));
        normalVec6.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal6 = new THREE.Vector3(0,0,1);

        const quaternionRotation6 = new THREE.Quaternion();
        quaternionRotation6.setFromUnitVectors(initialNormal6, normalVec6);

        ringMesh6.setRotationFromQuaternion(quaternionRotation6);

        return quaternionRotation6;
    }

    ringRoot.add(ringMesh6);
            
	var inradius7 = calulateInradius(getVertex4(), getVertex32(), getVertex33());
	var incenter7 = calulateIncenter(getVertex4(), getVertex32(), getVertex33());
	var ringGeometry7 = new THREE.RingGeometry((inradius7 - 0.005),inradius7, 32);
	const ringMaterial7 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh7 = new THREE.Mesh(ringGeometry7, ringMaterial7);

	function setCircleRotation7(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.5,0.86602540400000005,0.],[ 1.,1.154700539,0.81649658089999999],[0.5,0.2886751347,0.81649658089999999]);

        ringMesh7.position.setX(incenter[0]);
        ringMesh7.position.setY(incenter[1]);
        ringMesh7.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex32(), getVertex33());
        var relRadius = inradius/inradius7;

        ringMesh7.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A7 = new THREE.Vector3(0.5,0.86602540400000005,0.);
        const B7 = new THREE.Vector3(1.,1.154700539,0.81649658089999999);
        const C7 = new THREE.Vector3(0.5,0.2886751347,0.81649658089999999);

        const normalVec7 = new THREE.Vector3();
        normalVec7.crossVectors(B7.sub(A7), C7.sub(A7));
        normalVec7.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal7 = new THREE.Vector3(0,0,1);

        const quaternionRotation7 = new THREE.Quaternion();
        quaternionRotation7.setFromUnitVectors(initialNormal7, normalVec7);

        ringMesh7.setRotationFromQuaternion(quaternionRotation7);

        return quaternionRotation7;
    }

    ringRoot.add(ringMesh7);
            
	var inradius8 = calulateInradius(getVertex4(), getVertex33(), getVertex34());
	var incenter8 = calulateIncenter(getVertex4(), getVertex33(), getVertex34());
	var ringGeometry8 = new THREE.RingGeometry((inradius8 - 0.005),inradius8, 32);
	const ringMaterial8 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh8 = new THREE.Mesh(ringGeometry8, ringMaterial8);

	function setCircleRotation8(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.5,0.86602540400000005,0.],[ 0.5,0.2886751347,0.81649658089999999],[1.,0.,0.]);

        ringMesh8.position.setX(incenter[0]);
        ringMesh8.position.setY(incenter[1]);
        ringMesh8.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex33(), getVertex34());
        var relRadius = inradius/inradius8;

        ringMesh8.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A8 = new THREE.Vector3(0.5,0.86602540400000005,0.);
        const B8 = new THREE.Vector3(0.5,0.2886751347,0.81649658089999999);
        const C8 = new THREE.Vector3(1.,0.,0.);

        const normalVec8 = new THREE.Vector3();
        normalVec8.crossVectors(B8.sub(A8), C8.sub(A8));
        normalVec8.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal8 = new THREE.Vector3(0,0,1);

        const quaternionRotation8 = new THREE.Quaternion();
        quaternionRotation8.setFromUnitVectors(initialNormal8, normalVec8);

        ringMesh8.setRotationFromQuaternion(quaternionRotation8);

        return quaternionRotation8;
    }

    ringRoot.add(ringMesh8);
            
	var inradius16 = calulateInradius(getVertex24(), getVertex32(), getVertex33());
	var incenter16 = calulateIncenter(getVertex24(), getVertex32(), getVertex33());
	var ringGeometry16 = new THREE.RingGeometry((inradius16 - 0.005),inradius16, 32);
	const ringMaterial16 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh16 = new THREE.Mesh(ringGeometry16, ringMaterial16);

	function setCircleRotation16(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 1.,1.154700539,0.81649658089999999],[0.5,0.2886751347,0.81649658089999999]);

        ringMesh16.position.setX(incenter[0]);
        ringMesh16.position.setY(incenter[1]);
        ringMesh16.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex24(), getVertex32(), getVertex33());
        var relRadius = inradius/inradius16;

        ringMesh16.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A16 = new THREE.Vector3(1.5,0.2886751347,0.81649658089999999);
        const B16 = new THREE.Vector3(1.,1.154700539,0.81649658089999999);
        const C16 = new THREE.Vector3(0.5,0.2886751347,0.81649658089999999);

        const normalVec16 = new THREE.Vector3();
        normalVec16.crossVectors(B16.sub(A16), C16.sub(A16));
        normalVec16.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal16 = new THREE.Vector3(0,0,1);

        const quaternionRotation16 = new THREE.Quaternion();
        quaternionRotation16.setFromUnitVectors(initialNormal16, normalVec16);

        ringMesh16.setRotationFromQuaternion(quaternionRotation16);

        return quaternionRotation16;
    }

    ringRoot.add(ringMesh16);
            
	var inradius17 = calulateInradius(getVertex24(), getVertex32(), getVertex37());
	var incenter17 = calulateIncenter(getVertex24(), getVertex32(), getVertex37());
	var ringGeometry17 = new THREE.RingGeometry((inradius17 - 0.005),inradius17, 32);
	const ringMaterial17 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh17 = new THREE.Mesh(ringGeometry17, ringMaterial17);

	function setCircleRotation17(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 1.,1.154700539,0.81649658089999999],[2.,1.154700539,0.81649658089999999]);

        ringMesh17.position.setX(incenter[0]);
        ringMesh17.position.setY(incenter[1]);
        ringMesh17.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex24(), getVertex32(), getVertex37());
        var relRadius = inradius/inradius17;

        ringMesh17.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A17 = new THREE.Vector3(1.5,0.2886751347,0.81649658089999999);
        const B17 = new THREE.Vector3(1.,1.154700539,0.81649658089999999);
        const C17 = new THREE.Vector3(2.,1.154700539,0.81649658089999999);

        const normalVec17 = new THREE.Vector3();
        normalVec17.crossVectors(B17.sub(A17), C17.sub(A17));
        normalVec17.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal17 = new THREE.Vector3(0,0,1);

        const quaternionRotation17 = new THREE.Quaternion();
        quaternionRotation17.setFromUnitVectors(initialNormal17, normalVec17);

        ringMesh17.setRotationFromQuaternion(quaternionRotation17);

        return quaternionRotation17;
    }

    ringRoot.add(ringMesh17);
            
	var inradius18 = calulateInradius(getVertex24(), getVertex27(), getVertex37());
	var incenter18 = calulateIncenter(getVertex24(), getVertex27(), getVertex37());
	var ringGeometry18 = new THREE.RingGeometry((inradius18 - 0.005),inradius18, 32);
	const ringMaterial18 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh18 = new THREE.Mesh(ringGeometry18, ringMaterial18);

	function setCircleRotation18(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 2.5,0.2886751347,0.81649658089999999],[2.,1.154700539,0.81649658089999999]);

        ringMesh18.position.setX(incenter[0]);
        ringMesh18.position.setY(incenter[1]);
        ringMesh18.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex24(), getVertex27(), getVertex37());
        var relRadius = inradius/inradius18;

        ringMesh18.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A18 = new THREE.Vector3(1.5,0.2886751347,0.81649658089999999);
        const B18 = new THREE.Vector3(2.5,0.2886751347,0.81649658089999999);
        const C18 = new THREE.Vector3(2.,1.154700539,0.81649658089999999);

        const normalVec18 = new THREE.Vector3();
        normalVec18.crossVectors(B18.sub(A18), C18.sub(A18));
        normalVec18.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal18 = new THREE.Vector3(0,0,1);

        const quaternionRotation18 = new THREE.Quaternion();
        quaternionRotation18.setFromUnitVectors(initialNormal18, normalVec18);

        ringMesh18.setRotationFromQuaternion(quaternionRotation18);

        return quaternionRotation18;
    }

    ringRoot.add(ringMesh18);
            
	var inradius19 = calulateInradius(getVertex24(), getVertex27(), getVertex35());
	var incenter19 = calulateIncenter(getVertex24(), getVertex27(), getVertex35());
	var ringGeometry19 = new THREE.RingGeometry((inradius19 - 0.005),inradius19, 32);
	const ringMaterial19 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh19 = new THREE.Mesh(ringGeometry19, ringMaterial19);

	function setCircleRotation19(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 2.5,0.2886751347,0.81649658089999999],[2.,0.,0.]);

        ringMesh19.position.setX(incenter[0]);
        ringMesh19.position.setY(incenter[1]);
        ringMesh19.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex24(), getVertex27(), getVertex35());
        var relRadius = inradius/inradius19;

        ringMesh19.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A19 = new THREE.Vector3(1.5,0.2886751347,0.81649658089999999);
        const B19 = new THREE.Vector3(2.5,0.2886751347,0.81649658089999999);
        const C19 = new THREE.Vector3(2.,0.,0.);

        const normalVec19 = new THREE.Vector3();
        normalVec19.crossVectors(B19.sub(A19), C19.sub(A19));
        normalVec19.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal19 = new THREE.Vector3(0,0,1);

        const quaternionRotation19 = new THREE.Quaternion();
        quaternionRotation19.setFromUnitVectors(initialNormal19, normalVec19);

        ringMesh19.setRotationFromQuaternion(quaternionRotation19);

        return quaternionRotation19;
    }

    ringRoot.add(ringMesh19);
            
	var inradius20 = calulateInradius(getVertex24(), getVertex34(), getVertex35());
	var incenter20 = calulateIncenter(getVertex24(), getVertex34(), getVertex35());
	var ringGeometry20 = new THREE.RingGeometry((inradius20 - 0.005),inradius20, 32);
	const ringMaterial20 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh20 = new THREE.Mesh(ringGeometry20, ringMaterial20);

	function setCircleRotation20(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 1.,0.,0.],[2.,0.,0.]);

        ringMesh20.position.setX(incenter[0]);
        ringMesh20.position.setY(incenter[1]);
        ringMesh20.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex24(), getVertex34(), getVertex35());
        var relRadius = inradius/inradius20;

        ringMesh20.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A20 = new THREE.Vector3(1.5,0.2886751347,0.81649658089999999);
        const B20 = new THREE.Vector3(1.,0.,0.);
        const C20 = new THREE.Vector3(2.,0.,0.);

        const normalVec20 = new THREE.Vector3();
        normalVec20.crossVectors(B20.sub(A20), C20.sub(A20));
        normalVec20.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal20 = new THREE.Vector3(0,0,1);

        const quaternionRotation20 = new THREE.Quaternion();
        quaternionRotation20.setFromUnitVectors(initialNormal20, normalVec20);

        ringMesh20.setRotationFromQuaternion(quaternionRotation20);

        return quaternionRotation20;
    }

    ringRoot.add(ringMesh20);
            
	var inradius21 = calulateInradius(getVertex24(), getVertex33(), getVertex34());
	var incenter21 = calulateIncenter(getVertex24(), getVertex33(), getVertex34());
	var ringGeometry21 = new THREE.RingGeometry((inradius21 - 0.005),inradius21, 32);
	const ringMaterial21 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh21 = new THREE.Mesh(ringGeometry21, ringMaterial21);

	function setCircleRotation21(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 0.5,0.2886751347,0.81649658089999999],[1.,0.,0.]);

        ringMesh21.position.setX(incenter[0]);
        ringMesh21.position.setY(incenter[1]);
        ringMesh21.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex24(), getVertex33(), getVertex34());
        var relRadius = inradius/inradius21;

        ringMesh21.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A21 = new THREE.Vector3(1.5,0.2886751347,0.81649658089999999);
        const B21 = new THREE.Vector3(0.5,0.2886751347,0.81649658089999999);
        const C21 = new THREE.Vector3(1.,0.,0.);

        const normalVec21 = new THREE.Vector3();
        normalVec21.crossVectors(B21.sub(A21), C21.sub(A21));
        normalVec21.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal21 = new THREE.Vector3(0,0,1);

        const quaternionRotation21 = new THREE.Quaternion();
        quaternionRotation21.setFromUnitVectors(initialNormal21, normalVec21);

        ringMesh21.setRotationFromQuaternion(quaternionRotation21);

        return quaternionRotation21;
    }

    ringRoot.add(ringMesh21);
            
	var inradius22 = calulateInradius(getVertex27(), getVertex36(), getVertex37());
	var incenter22 = calulateIncenter(getVertex27(), getVertex36(), getVertex37());
	var ringGeometry22 = new THREE.RingGeometry((inradius22 - 0.005),inradius22, 32);
	const ringMaterial22 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh22 = new THREE.Mesh(ringGeometry22, ringMaterial22);

	function setCircleRotation22(){

        //translate ring to incenter
        var incenter = calulateIncenter([2.5,0.2886751347,0.81649658089999999],[ 2.5,0.86602540400000005,0.],[2.,1.154700539,0.81649658089999999]);

        ringMesh22.position.setX(incenter[0]);
        ringMesh22.position.setY(incenter[1]);
        ringMesh22.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex27(), getVertex36(), getVertex37());
        var relRadius = inradius/inradius22;

        ringMesh22.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A22 = new THREE.Vector3(2.5,0.2886751347,0.81649658089999999);
        const B22 = new THREE.Vector3(2.5,0.86602540400000005,0.);
        const C22 = new THREE.Vector3(2.,1.154700539,0.81649658089999999);

        const normalVec22 = new THREE.Vector3();
        normalVec22.crossVectors(B22.sub(A22), C22.sub(A22));
        normalVec22.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal22 = new THREE.Vector3(0,0,1);

        const quaternionRotation22 = new THREE.Quaternion();
        quaternionRotation22.setFromUnitVectors(initialNormal22, normalVec22);

        ringMesh22.setRotationFromQuaternion(quaternionRotation22);

        return quaternionRotation22;
    }

    ringRoot.add(ringMesh22);
            
	var inradius23 = calulateInradius(getVertex27(), getVertex35(), getVertex36());
	var incenter23 = calulateIncenter(getVertex27(), getVertex35(), getVertex36());
	var ringGeometry23 = new THREE.RingGeometry((inradius23 - 0.005),inradius23, 32);
	const ringMaterial23 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh23 = new THREE.Mesh(ringGeometry23, ringMaterial23);

	function setCircleRotation23(){

        //translate ring to incenter
        var incenter = calulateIncenter([2.5,0.2886751347,0.81649658089999999],[ 2.,0.,0.],[2.5,0.86602540400000005,0.]);

        ringMesh23.position.setX(incenter[0]);
        ringMesh23.position.setY(incenter[1]);
        ringMesh23.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex27(), getVertex35(), getVertex36());
        var relRadius = inradius/inradius23;

        ringMesh23.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A23 = new THREE.Vector3(2.5,0.2886751347,0.81649658089999999);
        const B23 = new THREE.Vector3(2.,0.,0.);
        const C23 = new THREE.Vector3(2.5,0.86602540400000005,0.);

        const normalVec23 = new THREE.Vector3();
        normalVec23.crossVectors(B23.sub(A23), C23.sub(A23));
        normalVec23.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal23 = new THREE.Vector3(0,0,1);

        const quaternionRotation23 = new THREE.Quaternion();
        quaternionRotation23.setFromUnitVectors(initialNormal23, normalVec23);

        ringMesh23.setRotationFromQuaternion(quaternionRotation23);

        return quaternionRotation23;
    }

    ringRoot.add(ringMesh23);
            	// function to update the circles every frame 
	function updateCircles(){
		setCircleRotation1();
		setCircleRotation2();
		setCircleRotation3();
		setCircleRotation4();
		setCircleRotation5();
		setCircleRotation6();
		setCircleRotation7();
		setCircleRotation8();
		setCircleRotation16();
		setCircleRotation17();
		setCircleRotation18();
		setCircleRotation19();
		setCircleRotation20();
		setCircleRotation21();
		setCircleRotation22();
		setCircleRotation23();
	}

	// needs to be called once to be initialized 
	updateCircles();

	// function to update the circles width, that is called every frame even if the surface is not parameterized 
	function updateCircleWidth(){
		ringGeometry1.dispose();
		ringGeometry1 = new THREE.RingGeometry((inradius1 - guiParameters.circleWidth),inradius1, 32);
		ringMesh1.geometry = ringGeometry1; 
		ringGeometry2.dispose();
		ringGeometry2 = new THREE.RingGeometry((inradius2 - guiParameters.circleWidth),inradius2, 32);
		ringMesh2.geometry = ringGeometry2; 
		ringGeometry3.dispose();
		ringGeometry3 = new THREE.RingGeometry((inradius3 - guiParameters.circleWidth),inradius3, 32);
		ringMesh3.geometry = ringGeometry3; 
		ringGeometry4.dispose();
		ringGeometry4 = new THREE.RingGeometry((inradius4 - guiParameters.circleWidth),inradius4, 32);
		ringMesh4.geometry = ringGeometry4; 
		ringGeometry5.dispose();
		ringGeometry5 = new THREE.RingGeometry((inradius5 - guiParameters.circleWidth),inradius5, 32);
		ringMesh5.geometry = ringGeometry5; 
		ringGeometry6.dispose();
		ringGeometry6 = new THREE.RingGeometry((inradius6 - guiParameters.circleWidth),inradius6, 32);
		ringMesh6.geometry = ringGeometry6; 
		ringGeometry7.dispose();
		ringGeometry7 = new THREE.RingGeometry((inradius7 - guiParameters.circleWidth),inradius7, 32);
		ringMesh7.geometry = ringGeometry7; 
		ringGeometry8.dispose();
		ringGeometry8 = new THREE.RingGeometry((inradius8 - guiParameters.circleWidth),inradius8, 32);
		ringMesh8.geometry = ringGeometry8; 
		ringGeometry16.dispose();
		ringGeometry16 = new THREE.RingGeometry((inradius16 - guiParameters.circleWidth),inradius16, 32);
		ringMesh16.geometry = ringGeometry16; 
		ringGeometry17.dispose();
		ringGeometry17 = new THREE.RingGeometry((inradius17 - guiParameters.circleWidth),inradius17, 32);
		ringMesh17.geometry = ringGeometry17; 
		ringGeometry18.dispose();
		ringGeometry18 = new THREE.RingGeometry((inradius18 - guiParameters.circleWidth),inradius18, 32);
		ringMesh18.geometry = ringGeometry18; 
		ringGeometry19.dispose();
		ringGeometry19 = new THREE.RingGeometry((inradius19 - guiParameters.circleWidth),inradius19, 32);
		ringMesh19.geometry = ringGeometry19; 
		ringGeometry20.dispose();
		ringGeometry20 = new THREE.RingGeometry((inradius20 - guiParameters.circleWidth),inradius20, 32);
		ringMesh20.geometry = ringGeometry20; 
		ringGeometry21.dispose();
		ringGeometry21 = new THREE.RingGeometry((inradius21 - guiParameters.circleWidth),inradius21, 32);
		ringMesh21.geometry = ringGeometry21; 
		ringGeometry22.dispose();
		ringGeometry22 = new THREE.RingGeometry((inradius22 - guiParameters.circleWidth),inradius22, 32);
		ringMesh22.geometry = ringGeometry22; 
		ringGeometry23.dispose();
		ringGeometry23 = new THREE.RingGeometry((inradius23 - guiParameters.circleWidth),inradius23, 32);
		ringMesh23.geometry = ringGeometry23; 
	}

	updateCircleWidth();

	// generate the normals trough the incenter orthogonal to the face 
	// getNormalsVectors generates the coordinates for the current values of the parameterized surface 
	function getNormalsVectors(){
		var vector1;
		var vector2;

		var normals = [];
		vector1 = [];
		vector2 = [];
		vector1[0] = (2.5)-(1.5);
		vector1[1] = (0.8660254040000001)-(0.8660254040000001);
		vector1[2] = (0.)-(0.);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (1.154700539)-(0.8660254040000001);
		vector2[2] = (0.8164965809)-(0.);

		var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 2.5,0.86602540400000005,0.],[2.,1.154700539,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.5);
		vector1[1] = (1.154700539)-(0.8660254040000001);
		vector1[2] = (0.8164965809)-(0.);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (1.154700539)-(0.8660254040000001);
		vector2[2] = (0.8164965809)-(0.);

		var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 1.,1.154700539,0.81649658089999999],[2.,1.154700539,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.5)-(1.5);
		vector1[1] = (0.8660254040000001)-(0.8660254040000001);
		vector1[2] = (0.)-(0.);

		vector2[0] = (1.)-(1.5);
		vector2[1] = (1.154700539)-(0.8660254040000001);
		vector2[2] = (0.8164965809)-(0.);

		var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 0.5,0.86602540400000005,0.],[1.,1.154700539,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.5)-(1.5);
		vector1[1] = (0.8660254040000001)-(0.8660254040000001);
		vector1[2] = (0.)-(0.);

		vector2[0] = (1.)-(1.5);
		vector2[1] = (0.)-(0.8660254040000001);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 0.5,0.86602540400000005,0.],[1.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.5);
		vector1[1] = (0.)-(0.8660254040000001);
		vector1[2] = (0.)-(0.);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (0.)-(0.8660254040000001);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 1.,0.,0.],[2.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (2.)-(1.5);
		vector1[1] = (0.)-(0.8660254040000001);
		vector1[2] = (0.)-(0.);

		vector2[0] = (2.5)-(1.5);
		vector2[1] = (0.8660254040000001)-(0.8660254040000001);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([1.5,0.86602540400000005,0.],[ 2.,0.,0.],[2.5,0.86602540400000005,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(0.5);
		vector1[1] = (1.154700539)-(0.8660254040000001);
		vector1[2] = (0.8164965809)-(0.);

		vector2[0] = (0.5)-(0.5);
		vector2[1] = (0.2886751347)-(0.8660254040000001);
		vector2[2] = (0.8164965809)-(0.);

		var incenter = calulateIncenter([0.5,0.86602540400000005,0.],[ 1.,1.154700539,0.81649658089999999],[0.5,0.2886751347,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.5)-(0.5);
		vector1[1] = (0.2886751347)-(0.8660254040000001);
		vector1[2] = (0.8164965809)-(0.);

		vector2[0] = (1.)-(0.5);
		vector2[1] = (0.)-(0.8660254040000001);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([0.5,0.86602540400000005,0.],[ 0.5,0.2886751347,0.81649658089999999],[1.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.5);
		vector1[1] = (1.154700539)-(0.2886751347);
		vector1[2] = (0.8164965809)-(0.8164965809);

		vector2[0] = (0.5)-(1.5);
		vector2[1] = (0.2886751347)-(0.2886751347);
		vector2[2] = (0.8164965809)-(0.8164965809);

		var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 1.,1.154700539,0.81649658089999999],[0.5,0.2886751347,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.5);
		vector1[1] = (1.154700539)-(0.2886751347);
		vector1[2] = (0.8164965809)-(0.8164965809);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (1.154700539)-(0.2886751347);
		vector2[2] = (0.8164965809)-(0.8164965809);

		var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 1.,1.154700539,0.81649658089999999],[2.,1.154700539,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (2.5)-(1.5);
		vector1[1] = (0.2886751347)-(0.2886751347);
		vector1[2] = (0.8164965809)-(0.8164965809);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (1.154700539)-(0.2886751347);
		vector2[2] = (0.8164965809)-(0.8164965809);

		var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 2.5,0.2886751347,0.81649658089999999],[2.,1.154700539,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (2.5)-(1.5);
		vector1[1] = (0.2886751347)-(0.2886751347);
		vector1[2] = (0.8164965809)-(0.8164965809);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (0.)-(0.2886751347);
		vector2[2] = (0.)-(0.8164965809);

		var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 2.5,0.2886751347,0.81649658089999999],[2.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.5);
		vector1[1] = (0.)-(0.2886751347);
		vector1[2] = (0.)-(0.8164965809);

		vector2[0] = (2.)-(1.5);
		vector2[1] = (0.)-(0.2886751347);
		vector2[2] = (0.)-(0.8164965809);

		var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 1.,0.,0.],[2.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.5)-(1.5);
		vector1[1] = (0.2886751347)-(0.2886751347);
		vector1[2] = (0.8164965809)-(0.8164965809);

		vector2[0] = (1.)-(1.5);
		vector2[1] = (0.)-(0.2886751347);
		vector2[2] = (0.)-(0.8164965809);

		var incenter = calulateIncenter([1.5,0.2886751347,0.81649658089999999],[ 0.5,0.2886751347,0.81649658089999999],[1.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (2.5)-(2.5);
		vector1[1] = (0.8660254040000001)-(0.2886751347);
		vector1[2] = (0.)-(0.8164965809);

		vector2[0] = (2.)-(2.5);
		vector2[1] = (1.154700539)-(0.2886751347);
		vector2[2] = (0.8164965809)-(0.8164965809);

		var incenter = calulateIncenter([2.5,0.2886751347,0.81649658089999999],[ 2.5,0.86602540400000005,0.],[2.,1.154700539,0.81649658089999999]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (2.)-(2.5);
		vector1[1] = (0.)-(0.2886751347);
		vector1[2] = (0.)-(0.8164965809);

		vector2[0] = (2.5)-(2.5);
		vector2[1] = (0.8660254040000001)-(0.2886751347);
		vector2[2] = (0.)-(0.8164965809);

		var incenter = calulateIncenter([2.5,0.2886751347,0.81649658089999999],[ 2.,0.,0.],[2.5,0.86602540400000005,0.]);
		normals.push([vector1, vector2, incenter]);

	return normals;
	}
	// getNormalsCoordinates calculates the right coordinates for the ortogonality and fitting values from the gui 
	function getNormalsCoordinates(){
		var res = [];
		var normals = getNormalsVectors(); 
        for(var i = 0; i < normals.length; i++){
            var plus = [];
            var minus = [];

            minus[0] = normals[i][2][0] - (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            minus[1] = normals[i][2][1] - (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            minus[2] = normals[i][2][2] - (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            plus[0] = normals[i][2][0] + (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            plus[1] = normals[i][2][1] + (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            plus[2] = normals[i][2][2] + (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            res.push(minus[0]);
            res.push(minus[1]);
            res.push(minus[2]);
            res.push(plus[0]);
            res.push(plus[1]);
            res.push(plus[2]);
        }
        res = Float32Array.from(res);

    
		return res;
	}


    const normalsMaterial = new THREE.LineBasicMaterial( {
        color: 0x000000,
    } );
    
    const normalsGeometry = new THREE.BufferGeometry();
    normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
    var normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );

    function updateNormals(){
        normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
        normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );
    }
    
    normalsRoot.add(normalsLine);

    
	// generate automatic ranges for the intersections if the surface is not parameterized 
	guiParameters.maxX = 2.5;
	guiParameters.maxY = 1.154700539;
	guiParameters.maxZ = 0.8164965809;
	guiParameters.minX = 0.;
	guiParameters.minY = 0.;
	guiParameters.minZ = 0.;

	guiParameters.planeX = 1.25;
	guiParameters.planeY = 0.5773502695;
	guiParameters.planeZ = 0.40824829045;
	// --- end of generated output --- //

    const planeFolder = gui.addFolder("Intersection Planes");
    planeFolder.add(guiParameters, 'planeXactive');
    planeFolder.add(guiParameters, 'planeX', guiParameters.minX*1.1, guiParameters.maxX*1.1);
    planeFolder.add(guiParameters, 'planeYactive');
    planeFolder.add(guiParameters, 'planeY', guiParameters.minY*1.1, guiParameters.maxY*1.1);
    planeFolder.add(guiParameters, 'planeZactive');
    planeFolder.add(guiParameters, 'planeZ', guiParameters.minZ*1.1, guiParameters.maxZ*1.1);
    
    camera.position.z = Math.min((1.5)*guiParameters.minZ, -1)
    camera.lookAt(0,0,-1);

    scene.background = new THREE.Color( 'white' );

    // add both roots to the scene
    scene.add( meshRoot );
    scene.add( wireRoot );
    scene.add( vertexRoot );
    scene.add( vertexlabelRoot );
    scene.add( edgeRoot );
    scene.add( ringRoot );
    scene.add( normalsRoot );
    scene.add( normalMeshRoot );

    //presave some current gui parameters to only update if they change
    var currentCircleWidth = guiParameters.circleWidth;

    function animate() {
        requestAnimationFrame( animate );
        meshRoot.rotation.x += guiParameters.speedX/100;
        meshRoot.rotation.y += guiParameters.speedY/100;
        meshRoot.rotation.z += guiParameters.speedZ/100;

        wireRoot.rotation.x += guiParameters.speedX/100;
        wireRoot.rotation.y += guiParameters.speedY/100;
        wireRoot.rotation.z += guiParameters.speedZ/100;

        vertexRoot.rotation.x += guiParameters.speedX/100;
        vertexRoot.rotation.y += guiParameters.speedY/100;
        vertexRoot.rotation.z += guiParameters.speedZ/100;

        vertexlabelRoot.rotation.x += guiParameters.speedX/100;
        vertexlabelRoot.rotation.y += guiParameters.speedY/100;
        vertexlabelRoot.rotation.z += guiParameters.speedZ/100;

        edgeRoot.rotation.x += guiParameters.speedX/100;
        edgeRoot.rotation.y += guiParameters.speedY/100;
        edgeRoot.rotation.z += guiParameters.speedZ/100;

        ringRoot.rotation.x += guiParameters.speedX/100;
        ringRoot.rotation.y += guiParameters.speedY/100;
        ringRoot.rotation.z += guiParameters.speedZ/100;

        normalsRoot.rotation.x += guiParameters.speedX/100;
        normalsRoot.rotation.y += guiParameters.speedY/100;
        normalsRoot.rotation.z += guiParameters.speedZ/100;

        normalMeshRoot.rotation.x += guiParameters.speedX/100;
        normalMeshRoot.rotation.y += guiParameters.speedY/100;
        normalMeshRoot.rotation.z += guiParameters.speedZ/100;

        //update the light when the camera moves (with orbitcontrols)
        light.position.set(camera.position.x, camera.position.y, camera.position.z);

        planeX.constant = guiParameters.planeX;
        planeY.constant = guiParameters.planeY;
        planeZ.constant = guiParameters.planeZ;

        activePlanes = [];
        if(guiParameters.planeXactive){
            activePlanes.push(planeX);
        }
        if(guiParameters.planeYactive){
            activePlanes.push(planeY);
        }
        if(guiParameters.planeZactive){
            activePlanes.push(planeZ);
        }

        if(vertexParametriziation){
            updateFaceCoordinates();
            if(guiParameters.edgeVisibility){
                updateEdgeCoordinates();
            }
            if(guiParameters.vertexlabelVisibility || guiParameters.vertexVisibility){
                updateVertexCoordinates();
            }
            if(guiParameters.circleVisibility){
                updateCircles();
            }
        }                

        //update stuff that changes from the gui
        meshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        normalMeshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(!guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        edgeRoot.traverse( function( node ) {
            if ( node instanceof Line2 ) {
                node.material.visible = guiParameters.edgeVisibility;
                node.material.linewidth = guiParameters.edgeWidth/100;
            }
            if ( node instanceof THREE.LineSegments ) {
                node.material.visible = guiParameters.edgeVisibility;
            }
        } );

        vertexRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.visible = guiParameters.vertexVisibility;
                node.scale.setScalar(guiParameters.vertexSize);
            }
        } );

        vertexlabelRoot.traverse( function( node ) {
            if( node instanceof CSS2DObject) {
                node.visible = guiParameters.vertexlabelVisibility;
            }
        } );

        ringRoot.traverse( function( node ) {
            if( node instanceof THREE.Mesh) {
                node.visible = guiParameters.circleVisibility;
            }
        } );

        normalsRoot.traverse( function( node ) {
            if( node instanceof THREE.LineSegments) {
                node.visible = guiParameters.normalsVisibility;
            }
        } );

        // update the circle width
        if(guiParameters.circleVisibility && currentCircleWidth != guiParameters.circleWidth){
            updateCircleWidth();
            currentCircleWidth = guiParameters.circleWidth;
        }

        //update the normals length 
        if(guiParameters.normalsVisibility){
            updateNormals();
        }

        controls.update();

        renderer.localClippingEnabled = true;

        renderer.render( scene, camera );
        labelRenderer.render( scene, camera );
    }
    animate();

    //resize of window size changes
    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        labelRenderer.setSize( window.innerWidth, window.innerHeight );
    }
</script>

</body>
</html>